#!/usr/bin/env python

from __future__ import print_function

import argparse
import ipaddress
import os
import re
import subprocess
import sys
import yaml


DEFAULT_DOMAIN_LISTS_FILE = "{{domain_lists_file}}"
DEFAULT_DOMAIN_LISTS_DIR = "{{domain_lists_dir}}"
DEFAULT_ZONES_DIR = "{{zones_dir}}"


def _parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("--lists-file", default=DEFAULT_DOMAIN_LISTS_FILE)
    parser.add_argument("--lists-dir", default=DEFAULT_DOMAIN_LISTS_DIR)
    parser.add_argument("--zones-dir", default=DEFAULT_ZONES_DIR)

    reload_bind_group = parser.add_mutually_exclusive_group()
    reload_bind_group.add_argument(
        "--reload-bind",
        action="store_true",
        dest="reload_bind",
    )
    reload_bind_group.add_argument(
        "--no-reload-bind",
        action="store_false",
        dest="reload_bind",
    )

    return parser.parse_args()


def _read_domain_lists_file(domain_lists_file_path):
    return yaml.load(open(domain_lists_file_path, "r"), Loader=yaml.SafeLoader)


def _db_file_path(zones_dir, list_zone):
    return os.path.join(zones_dir, "db-forward.{}.records".format(list_zone))


def _domain_list_file_path(lists_dir, list_name):
    return os.path.join(lists_dir, "list.{}".format(list_name))


def _db_file_outdated(db_file_path, list_file_path):
    try:
        return os.path.getmtime(db_file_path) > os.path.getmtime(list_file_path)
    except OSError:
        return False


def _domain_to_record(domain, record):
    return "{} {}\n".format(domain, record)


def _is_domain_name(candidate):
    try:
        # IP addresses are not valid domain names.
        ipaddress.ip_address(unicode(candidate))
        return False
    except ValueError:
        pass

    # Valid domain names have at least two domain-parts separated by a `.`.
    domain_part, _, top_level_domain = candidate.rpartition(".")
    return domain_part and top_level_domain


def _strip_comments(content):
    return "\n".join(
        [re.sub(r"#.*$", r"", line) for line in content.splitlines()],
    )


def _generate_domains(content):
    # Extract "words" from `content`, and yield any that pass our domain filter.
    for match in re.finditer(r"(\S+)", _strip_comments(content)):
        for group in match.groups():
            domain_candidate = group.lower()
            if _is_domain_name(domain_candidate):
                yield domain_candidate


def _domain_list_file_to_db_file(domains, record, db_file):
    with open(db_file, "w") as f:
        for domain in domains:
            f.write(_domain_to_record(domain, record))


def _domain_lists_to_db_file(zone, zones_dir, lists_dir):
    db_file_path = _db_file_path(zones_dir, zone["zone"])

    updated = []
    domains = set()
    for domain_list in zone["lists"]:
        domain_list_file_path = _domain_list_file_path(
            lists_dir,
            domain_list["name"],
        )
        if _db_file_outdated(db_file_path, domain_list_file_path):
            updated.append(domain_list)

        domain_file_content = open(domain_list_file_path, "r").read()
        for domain in _generate_domains(domain_file_content):
            domains.add(domain)

    _domain_list_file_to_db_file(sorted(domains), zone["record"], db_file_path)

    return updated


def _domain_lists_to_db_files(zones, *args, **kwargs):
    updated = []
    for zone in zones:
        updated.extend(_domain_lists_to_db_file(zone, *args, **kwargs))
    return updated


def _reload_bind():
    service_name = "bind9.service"
    try:
        subprocess.check_output(["systemctl", "status", service_name])
    except subprocess.CalledProcessError:
        print("BIND9 service is not running, so it will not be reloaded.")
    else:
        print("Reloading BIND9 service")
        subprocess.check_output(["systemctl", "reload", service_name])


def main():
    args = _parse_args()

    domain_lists_zones = _read_domain_lists_file(args.lists_file)
    updated = _domain_lists_to_db_files(
        domain_lists_zones,
        args.zones_dir,
        args.lists_dir,
    )

    if updated and (args.reload_bind is True or args.reload_bind is None):
        _reload_bind()

    return 0


if __name__ == "__main__":
    sys.exit(main())
